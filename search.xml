<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[悲观锁和乐观锁]]></title>
      <url>%2F2017%2F03%2F11%2F%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%2F</url>
      <content type="text"><![CDATA[悲观锁和乐观锁为什么需要锁在多用户环境中，在同一时间可能会有多个用户更新相同的记录，就会产生冲突。冲突最终会导致丢失更新或脏读。 丢失更新：一个事务的更新覆盖了其它事务的更新结果。脏读：当一个事务读取其它完成一半事务的记录时，就会发生脏读取。表现为不同用户读到的同一个记录的值可能不同。 悲观锁还是乐观锁可以认为是一种思想。不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像 memcache、hibernate、tair 等都有类似的概念。不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。 当一个用户锁住数据库中的某个对象时，其他用户就不能再访问该对象。加锁对并发访问的影响体现在锁的粒度上。比如，放在一个表上的锁限制对整个表的并发访问；放在数据页上的锁限制了对整个数据页的访问；放在行上的锁只限制对该行的并发访问。可见行锁粒度最小，并发访问最好，页锁粒度最大，表锁介于两者之间。 悲观锁(Pessimistic Lock)假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。每次拿数据的时候都会担心会被别人修改（疑心重很悲观），所以每次在拿数据的时候都会上锁。确保自己使用的过程中不会被别人访问，自己使用完后再解锁，期间需要访问该数据的都会等待。 在数据库中，悲观锁的流程如下：在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 MySQL InnoDB中使用悲观锁：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0; MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。 悲观锁机制存在以下问题： 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。一个线程持有锁会导致其它所有需要此锁的线程挂起。如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。 乐观锁(Optimistic Lock)所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。[1] 乐观锁不能解决脏读的问题。每次拿数据的时候都完全不担心会被别人修改（心态好很乐观），所以每次在拿数据的时候都不会上锁。但是在更新数据的时候去判断该期间是否被别人修改过（使用版本号等机制），期间该数据可以随便被其他人读取。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本或使用时间戳。 使用方式 使用自增长的整数表示数据版本号。更新时检查版本号是否一致，比如数据库中数据版本为6，更新提交时version=6+1,使用该version值(=7)与数据库version+1(=7)作比较，如果相等，则可以更新，如果不等则有可能其他程序已更新该记录，所以返回错误。 使用时间戳来实现. 对于以上两种方式,Hibernate自带实现方式：在使用乐观锁的字段前加annotation: @Version, Hibernate在更新时自动校验该字段。 使用场景两种锁各有优缺点，不能单纯的定义哪个好于哪个。乐观锁比较适合数据修改比较少，并发量比较大，读取比较频繁的场景。但是如果经常发生冲突（写数据比较多的情况下），并发量不大且不允许脏读，上层应用不不断的retry，这样反而降低了性能，对于这种情况使用悲观锁就更合适。 java中的使用乐观锁是一种思想。CAS是这种思想的一种实现方式。乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。上面提到的乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。CAS是项乐观锁技术，CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。在JDK1.5 中新增java.util.concurrent(J.U.C)就是建立在CAS之上的。相对于对于synchronized这种阻塞算法，CAS是非阻塞算法的一种常见实现，所以J.U.C在性能上有了很大的提升。 参考：乐观锁的一种实现方式——CAS：http://www.hollischuang.com/archives/1537 Java中的线程安全问题至关重要，要想保证线程安全，就需要锁机制。锁机制包含两种：乐观锁与悲观锁。悲观锁是独占锁，阻塞锁。乐观锁是非独占锁，非阻塞锁。有一种乐观锁的实现方式就是CAS ，这种算法在JDK 1.5中引入的java.util.concurrent中有广泛应用。但是值得注意的是这种算法会存在ABA问题。 参考资料关于悲观锁和乐观锁的区别 深入理解乐观锁与悲观锁]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线程执行顺序——CountDownLatch、CyclicBarrier 、join()、线程池]]></title>
      <url>%2F2017%2F01%2F25%2F%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E2%80%94%E2%80%94CountDownLatch%E3%80%81CyclicBarrier%E3%80%81join()%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[本文主要围绕一个问题展开：线程执行顺序，比如某个线程在其他线程并发执行完毕后最后执行，分别用CountDownLatch、CyclicBarrier 、join()、线程池 来实现。 CyclicBarrierCyclicBarrier 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它可以让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法。 CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。CyclicBarrier还提供一个构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction这个Runnable对象，方便处理更复杂的业务场景。 实现原理在CyclicBarrier的内部定义了一个Lock对象，每当一个线程调用CyclicBarrier的await方法时，将剩余拦截的线程数减1，然后判断剩余拦截数是否为0，如果不是，进入Lock对象的条件队列等待。如果是则执行barrierAction对象的Runnable方法，然后将锁的条件队列中的所有线程放入锁等待队列中，这些线程会依次的获取锁、释放锁，接着先从await方法返回，再从CyclicBarrier的await方法中返回。 使用场景CyclicBarrier主要用于一组线程之间的相互等待，而CountDownLatch一般用于一组线程等待另一组些线程。实际上可以通过CountDownLatch的countDown()和await()来实现CyclicBarrier的功能。即 CountDownLatch中的countDown()+await() = CyclicBarrier中的await()。注意：在一个线程中先调用countDown()，然后调用await()。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243public class CyclicBarrierPractice &#123; static class Worker implements Runnable&#123; private String name; private CyclicBarrier cyclicBarrier; public Worker(String name, CyclicBarrier cyclicBarrier)&#123; this.name = name; this.cyclicBarrier = cyclicBarrier; &#125; public void run()&#123; System.out.println(name + " is working"); try &#123; Thread.sleep(1000); cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class Boss implements Runnable&#123; private String name; public Boss(String name)&#123; this.name = name; &#125; public void run()&#123; System.out.println(name + " checking work"); &#125; &#125; public static void main(String[] args)&#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(3, new Boss("boss")); for(int i=0; i&lt;3; i++)&#123; new Thread(new Worker("worker"+i, cyclicBarrier)).start(); &#125; &#125;&#125; 运行结果1234worker0 is workingworker1 is workingworker2 is workingboss checking work joinjoin()是Thread类的一个方法，join()方法的作用是等待这个线程结束。t.join()方法阻塞调用此方法的线程(calling thread)，直到线程t完成，此线程再继续；通常用于在main()主线程内，等待其它线程完成再结束main()主线程。 join实现Join方法实现是通过wait（Object 提供的方法）。 比如当main线程调用t.join时候，main线程会获得线程对象t的锁（wait 意味着拿到该对象的锁),调用该对象的wait(等待时间)，直到该对象唤醒main线程，比如退出后。这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁。 示例用join方式实现问题如下，在代码中main线程被阻塞直到 thread1，thread2执行完，主线程才会顺序的执行thread3. 1234567891011121314151617181920212223242526272829303132333435363738394041public class OrderThreadExecute &#123; class OrderThread implements Runnable&#123; private String name; public OrderThread(String name)&#123; this.name = name; &#125; public void run()&#123; System.out.println(name + " is working"); &#125; &#125; public static void main(String[] args) &#123; //使用join方法顺序执行 OrderThread worker1 = orderThread.new OrderThread("worker1"); OrderThread worker2 = orderThread.new OrderThread("worker2"); OrderThread boss = orderThread.new OrderThread("boss"); Thread thread1 = new Thread(worker1); Thread thread2 = new Thread(worker2); Thread thread3 = new Thread(boss); thread1.start(); thread2.start(); try &#123; thread1.join(); thread2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; thread3.start(); &#125;&#125; CountDownLatchJava的util.concurrent包里面的CountDownLatch其实可以把它看作一个计数器（倒计时锁），只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。 你可以向CountDownLatch对象设置一个初始的数字作为计数值，任何调用这个对象上的await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为0为止。 使用场景CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。 实例举个例子，有三个工人在为老板干活，这个老板有一个习惯，就是当三个工人把一天的活都干完了的时候，他就来检查所有工人所干的活。记住这个条件：三个工人先全部干完活，老板才检查。所以在这里用Java代码设计两个类，Worker代表工人，Boss代表老板，代码使用了内部类实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class OrderThreadExecute &#123; class Worker implements Runnable &#123; private CountDownLatch downLatch; private String name; public Worker(CountDownLatch downLatch, String name) &#123; this.downLatch = downLatch; this.name = name; &#125; @Override public void run() &#123; this.doWork(); try &#123; TimeUnit.SECONDS.sleep(new Random().nextInt(10)); &#125; catch (InterruptedException ie) &#123; &#125; System.out.println(this.name + "活干完了！"); this.downLatch.countDown(); &#125; private void doWork() &#123; System.out.println(this.name + "正在干活..."); &#125; &#125; class Boss implements Runnable &#123; private CountDownLatch downLatch; public Boss(CountDownLatch downLatch) &#123; this.downLatch = downLatch; &#125; @Override public void run() &#123; System.out.println("老板正在等所有的工人干完活......"); try &#123; this.downLatch.await(); &#125; catch (InterruptedException e) &#123; &#125; System.out.println("工人活都干完了，老板开始检查了！"); &#125; &#125; public static void main(String[] args) &#123; ExecutorService executor = Executors.newCachedThreadPool(); CountDownLatch latch = new CountDownLatch(3); OrderThreadExecute orderThread = new OrderThreadExecute(); Worker w1 = orderThread.new Worker(latch, "张三"); Worker w2 = orderThread.new Worker(latch, "李四"); Worker w3 = orderThread.new Worker(latch, "王二"); Boss boss = orderThread.new Boss(latch); executor.execute(boss); executor.execute(w3); executor.execute(w2); executor.execute(w1); executor.shutdown(); &#125;&#125; CountDownLatch与join比较调用thread.join() 方法必须等thread 执行完毕，当前线程才能继续往下执行，而CountDownLatch通过计数器提供了更灵活的控制，只要检测到计数器为0当前线程就可以往下执行而不用管相应的thread是否执行完毕。 具体比较见文章：http://blog.csdn.net/nyistzp/article/details/51444487 使用线程池当线程池的线程全部执行完毕后执行，勉强也算吧，示例代码如下。 1234567891011121314151617181920212223242526272829303132333435363738public class ExecuteOrderPractice &#123; public void orderPractice()&#123; ExecutorService executorService = Executors.newFixedThreadPool(3); for(int i = 0; i &lt; 5; i++)&#123; executorService.execute(new Runnable() &#123; @Override public void run() &#123; try&#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + " do something"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; executorService.shutdown(); while(true)&#123; if(executorService.isTerminated())&#123; System.out.println("Finally do something "); break; &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args)&#123; new ExecuteOrderPractice().orderPractice(); &#125;&#125; 引申如何每个线程都顺序执行，听起来好像为什么还要用多线程呢，有空再看吧 参考资料java 多线程 CountDownLatch与join()方法区别CountDownLatch使用实例Java如何判断线程池所有任务是否执行完毕]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sql重复插入问题]]></title>
      <url>%2F2017%2F01%2F13%2Fsql%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[sql重复插入问题问题在项目中，由于别人并发的调用接口，导致插入了重复数据 解决方案1.因为使用多台机器部署，可以使用分布式锁用一台机器处理，对处理的方法加锁或同步关键字，但性能会有很大影响，分布式的优势也没了2.在MySQL的业务表中，根据业务建立唯一索引，防止数据重复 具体操作建立唯一索引：1ALTER TABLE table_name ADD UNIQUE index_name (column_list) 程序中处理如果重复插入，MySQL好像会报数据完整性的错误，到spring中后错误被封装为 DuplicateKeyException，只要在程序中捕获这个异常做相应的处理就可以了。 重复插入语句建立唯一索引或使用主键primary后，还可以使用MySQL的重复插入语句：ignore， replace， ON DUPLICATE KEY UPDATE 1INSERT IGNORE INTO `table_name` (`email`, `phone`, `user_id`) VALUES ('test@163.com', '99999', '9999'); 这样当有重复记录就会忽略,执行后返回数字0 1REPLACE INTO `table_name`(`col_name`, ...) VALUES (...); REPLACE的运行与INSERT很相像,但是如果旧记录与新记录有相同的值，则在新记录被插入之前，旧记录被删除。 1INSERT INTO `table` (`a`, `b`, `c`) VALUES (1, 2, 3) ON DUPLICATE KEY UPDATE `c`=`c`+1; 如果行作为新记录被插入，则受影响行的值为1；如果原有的记录被更新，则受影响行的值为2。 这部分具体可参考 http://www.111cn.net/database/mysql/50135.htm #总结不过实际发现异常处理的时间要比MySQL的重复插入语句慢不少,所以可以的话还是使用MySQL的重复插入语句，不要在程序中去处理；但如果业务原因，可能也不得不在程序中处理，比如重复插入了，也要返回插入的数据信息。 INNODB中NULL字段使用插曲 在大多数情况下字段设计应该避免使用default null的使用，而使用空字符来代表空。因为INNODB的索引中会存储NULL，如果一个字段可为NULL，并且在该字段上有索引，索引中会存储NULL，每次索引的时候会额外扫更多的字段。在需要使用唯一索引约束一个字段，但是需要部分字段为空时，空字符串会引起唯一索引冲突，NULL可以在唯一索引中不产生冲突。可参考文章：http://tomblog.readthedocs.io/en/latest/mysql/INNODB%E4%B8%ADNULL%E4%BD%BF%E7%94%A8.htmlMysql联合唯一索引和空值: http://tomblog.readthedocs.io/en/latest/mysql/INNODB中NULL使用.html 参考资料MySql避免重复插入记录方法(ignore,Replace,ON DUPLICATE KEY UPDATE)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nginx的 http_image_filter_module 模块使用说明]]></title>
      <url>%2F2016%2F11%2F22%2FNginx%E7%9A%84%20http_image_filter_module%20%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
      <content type="text"><![CDATA[Nginx的 http_image_filter_module 模块使用说明Nginx图片处理原理这里需要用到 nginx的 http_image_filter_module 模块，这个模块可以很方便的实现图片缩放功能，只是默认的情况下并不会安装，需要自己编译安装才能行。编译的时候./configure 增加 –with-http_image_filter_module 编译安装即可 Nginx图片处理的优缺点优点 操作简单。通过简单配置，省去了后端裁剪程序的复杂性。 实时裁剪。可以实时访问在线裁剪图片。 灵活性强。后端程序裁剪图片时需要知道裁剪图片的尺寸和质量，使用nginx裁剪可以实时裁剪任意尺寸的图片。 不占用硬盘空间。 缺点 消耗CPU和内存，访问量大的时候就会给服务器带来很大的负担。(可以通过使用Nginx缓存和缓存服务器来解决) 功能不是很强大，支持的处理图片类型只包括JPEG, GIF, PNG, or WebP Nginx图片处理模块指令使用image_filter （重要）设置要在图像上执行的转换类型 Syntax: image_filter off; image_filter test; image_filter size; image_filter rotate 90/180/270; image_filter resize width height; image_filter crop width height; Default: image_filter off; Context: location test确保响应图片是JPEG、GIF，WEBP或PNG格式，否则返回415错误码。 size1234567outputs information about images in a JSON format, e.g.: &#123; "img" : &#123; "width": 100, "height": 100, "type": "gif" &#125; &#125; In case of an error, the output is as follows: &#123;&#125; 以 json 格式返回原图的尺寸和类型 rotate逆时针旋转指定角度，只能指定这三个角度。参数值可以包含变量，这个模式可以单独使用也可以和resize、crop变换同时使用。 resize width height按比例对图像进行缩放，可以只指定一个尺寸，另一个尺寸用“-”。如果遇到错误，服务器返回415错误码。参数值可以包含变量。当与rotate参数一同使用时，旋转操作发生在缩放之后。图片会以长的一边为标准，然后等比缩放。 crop width height按比例裁剪图片，可以只指定一个尺寸，另一个尺寸用“-”。如果遇到错误，服务器返回415错误码。参数值可以包含变量。当与rotate参数一同使用时，旋转操作发生在裁剪之前。图片会以长的一边为标准，然后等比缩放，然后裁剪掉多余的部分。 image_filter_buffer 设置用于读取图像的缓冲区的最大大小 Syntax: image_filter_buffer size; Default: image_filter_buffer 1M; Context: http, server, location 设置读取图片的最大缓冲区大小。当超过缓冲区大小时，返回 error 415 (Unsupported Media Type). image_filter_interlace 如果启用，最终图像将隔行扫描 Syntax: image_filter_interlace on / off; Default: image_filter_interlace off; Context: http, server, location 如果开启此功能，最终的图像是交错的。对于JPEG，最终图片是“渐进式JPEG”格式。图片一般是线性加载，设置后则变为交替加载图片。渐进式jpeg效果参见：http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/ image_filter_jpeg_quality设置转换JPEG图像的质量 Syntax: image_filter_jpeg_quality quality; Default: image_filter_jpeg_quality 75; Context: http, server, location 设置转为JPEG图像的质量。接受的值从1到100。较小的值意味着低质的图片质量和更少的数据传输量。最大建议的值是95。参数可以包含变量。 image_filter_sharpen通过设置锐化度，增加最终图像的清晰度。 Syntax: image_filter_sharpen percent; Default: image_filter_sharpen 0; Context: http, server, location 增加最终图片的锐度。这个百分比可以超过100。0值禁用此功能。参数可以包含变量。 image_filter_transparency定义是否透明度时应保留转换GIF图像或PNG图像的调色板中指定的颜色。 Syntax: image_filter_transparency on/off; Default: image_filter_transparency on; Context: http, server, location 决定在转换GIF或PNG图片带有调色板定义的颜色时，透明是否会保留。丢失透明度可以是图片得到更好的质量。PNG的Alpha通道的透明总是会保留。 image_filter_webp_quality设置转化WebP图像所需的质量 Syntax: image_filter_webp_quality quality; Default: image_filter_webp_quality 80; Context: http, server, location 设置转为webp图像的质量。 This directive appeared in version 1.11.6. 局限性 Nginx 的图片处理模块，暂时没有看到官方发布的能够给图片加水印功能的模块，在github上看到有人写了些这样的扩展功能，参见 https://github.com/3078825/ngx_image_thumb Nginx 的实时性和访问的方便性上，GraphicsMagick 是无法比拟的，但是 GraphicsMagick 对图片的处理的功能要比nginx强大很多，比如nginx不能将图片旋转任意角度，不能在图片上加水印，处理图片类型有限等，相对nginx，GraphicsMagick 更适合对图片的异步处理。 参考文献Module ngx_http_image_filter_module]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java——线程池]]></title>
      <url>%2F2016%2F11%2F12%2FJava%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[Java 线程池线程池线程池负责管理工作线程，包含一个等待执行的任务队列。线程池的任务队列是一个 Runnable集合，工作线程负责从任务队列中取出并执行Runnable对象。Executor 框架便是 Java 5 中引入的，其内部使用了线程池机制，Executor 框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable 等。 单线程的弊端 每次new Thread新建对象性能差。 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或 oom。 缺乏更多功能，如定时执行、定期执行、线程中断。 不控制线程数量，不断创建新线程，很快会导致oom，线程还是很占用资源的，线程栈的大小，JDK5.0以后每个线程堆栈大小默认为1M,以前每个线程堆栈大小为256K；可以通过jvm参数-Xss来设置；注意-Xss是jvm的非标准参数，不强制所有平台的jvm都支持。 线程池的优点 降低资源消耗。使用线程池的好处是重用存在的线程，减少在创建和销毁线程上所花的时间以及系统资源的开销，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。 提高响应速度。重用存在的线程，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。提供定时执行、定期执行、单线程、并发数控制等功能，线程池可以进行统一的分配，调优和监控。 线程池分类Executors 提供了一系列工厂方法用于创先线程池，返回的线程池都实现了 ExecutorService 接口。 newCachedThreadPool:创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。缓存型池子通常用于执行一些生存期很短的异步型任务 因此在一些面向连接的 daemon 型 SERVER 中用得不多。但对于生存期短的异步任务，它是 Executor 的首选。不限制线程数，可能会导致oom。 newFixedThreadPool: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool: 创建一个定长线程池，支持定时及周期性任务执行，多数情况下可用来替代Timer类。 newSingleThreadExecutor: 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 核心类ThreadPoolExecutorjava.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，有四个构造方法，拿一个构造方法举例。 123 public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler); ... corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中； keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0； workQueue：一个阻塞队列，用来存储等待执行的任务。ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。 threadFactory：线程工厂，主要用来创建线程； handler：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。有以下四种取值： 1234ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常(默认采取的策略)。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 线程池执行任务方法execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。但是execute方法没有返回值，所以无法判断任务是否被线程池执行成功。 submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，submit()执行 Callable 任务，会发现它实际上还是调用的execute()方法，利用了Future来获取任务执行结果。（代码示例参见：http://wiki.jikexueyuan.com/project/java-concurrency/executor.html） 线程池关闭我们可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。 只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。 shutdown()方法使线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕； shutdownNow()方法使线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务； 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。 通过类ThreadPoolExecutor线程执行的源码分析可以参考文章：http://www.cnblogs.com/dolphin0520/p/3932921.html 线程池监控ThreadPoolExecutor 提供了一些方法，可以查看执行状态、线程池大小、活动线程数和任务数。 1234567 getPoolSize() 线程池的线程数量。 getCorePoolSize() 线程池基本线程数。 getActiveCount() 活跃线程数 getCompletedTaskCount() 获取完成任务数 getTaskCount() 计划要执行任务数，不一定准确 isShutdown() 线程池的状态是否是shutdown isTerminated() 所有任务是否都执行完毕 通过扩展线程池进行监控。通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。 线程池执行任务流程 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务； 如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务； 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理； 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。 如何合理配置线程池的大小获取cpu核数：Runtime.getRuntime().availableProcessors(); 一般需要根据任务的类型来配置线程池大小： 如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1如果是IO密集型任务，参考值可以设置为2*NCPU 当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。 可能出现的问题下面这段引用来自阿里的java开发规范 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。Executors 返回的线程池对象的弊端如下,FixedThreadPool和SingleThreadPool允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。CachedThreadPool和ScheduledThreadPool允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。 建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。 参考资料JAVA THREAD POOLJava并发编程：线程池的使用（很细致的好文章）聊聊并发（三）——JAVA线程池的分析和使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 Grapicmagick 和 Im4java 处理图片]]></title>
      <url>%2F2016%2F09%2F18%2F%E4%BD%BF%E7%94%A8%20Grapicmagick%20%E5%92%8C%20Im4java%20%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%2F</url>
      <content type="text"><![CDATA[使用 Grapicmagick 和 Im4java 处理图片ImageMagick是个图片处理工具可以安装在绝大多数的平台上使用，Linux、Mac、Windows都没有问题。GraphicsMagick是在ImageMagick基础上的另一个项目，大大提高了图片处理的性能，在linux平台上，可以使用命令行的形式处理图片。Im4java 和Jmagick 都是开源社区为上面两个工具开发的 Java API，性能和方便度上im4java是更好的选择。 JMagick vs Im4Java JMagick是一个开源API，利用JNI(Java Native Interface)技术实现了对ImageMagick API的Java访问接口,因此也将比纯Java实现的图片操作函数在速度上要快。JMagick只实现了ImageMagicAPI的一部分功能，它的发行遵循LGPL协议。 im4java是ImageMagick的另一个Java开源接口。与JMagick不同之处在于im4java只是生成与ImageMagick相对应的命令行，然后将生成的命令行传至选中的ImageCommand（使用java.lang.ProcessBuilder.start()实现）来执行相应的操作。它支持大部分ImageMagick命令，可以针对不同组的图片多次复用同一个命令行。 im4java只是封装ImageMagick的命令。所以不需要依赖dll，也不存在64位系统调用32位dll的问题.而且im4java支持GraphicsMagick，GraphicsMagick是ImageMagick的分支。相对ImageMagick ,GraphicsMagick更稳定，消耗资源更少。最重要的是不依赖dll环境所以使用 im4java 是更好的选择。 Im4java处理图片示例这篇文章主要是 im4java 的使用，而 im4java 又是对 GraphicsMagick 命令的封装，GraphicsMagick 命令的使用可以看另一篇文章 GraphicsMagick 1.3.23 常用命令 先写个包含获取图片信息的简单工具类，如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class Im4JavaUtils &#123; private static Logger logger = LoggerFactory.getLogger(Im4JavaUtils.class); // 图片质量 public static final String IMAGE_QUALITY = "quality"; // 图片高度 public static final String IMAGE_HEIGHT = "height"; // 图片宽度 public static final String IMAGE_WIDTH = "width"; // 图片格式 public static final String IMAGE_SUFFIX = "suffix"; // 图片大小 public static final String IMAGE_SIZE = "size"; // 图片路径 public static final String IMAGE_PATH = "path"; /** * 是否使用 GraphicsMagick */ private static final boolean IS_USE_GRAPHICS_MAGICK = true; /** * ImageMagick安装路径，windows下使用 */ private static final String IMAGE_MAGICK_PATH = "D:\\software\\ImageMagick-6.2.7-Q8"; /** * gm 命令所在目录 */ private static final String GRAPHICS_MAGICK_PATH = "/usr/local/bin"; /** * 水印图片路径 */ private static final String watermarkImagePath = "/Users/gary/Documents/Job/ImageProcessTool/Im4java/Linux_logo.jpg"; /** * 水印图片 */ private static Image watermarkImage = null; static &#123; try &#123; watermarkImage = ImageIO.read(new File(watermarkImagePath)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 命令类型 * */ private enum CommandType &#123; convert("转换处理"), identify("图片信息"), compositecmd("图片合成"); private String name; CommandType(String name) &#123; this.name = name; &#125; &#125; /** * 查询图片的基本信息:格式,质量，宽度，高度 * &lt;p&gt; * gm identify -format %w,%h,%d/%f,%Q,%b,%e /Users/gary/Documents/999999999/10005582/1.jpg * &lt;p&gt; * * @param imagePath * @return */ public static Map&lt;String, String&gt; getImageInfo(String imagePath) &#123; long startTime = System.currentTimeMillis(); Map&lt;String, String&gt; imageInfo = new HashMap&lt;&gt;(); try &#123; IMOperation op = new IMOperation(); op.format("%w,%h,%d/%f,%Q,%b,%e"); op.addImage(); ImageCommand identifyCmd = getImageCommand(CommandType.identify); ArrayListOutputConsumer output = new ArrayListOutputConsumer(); identifyCmd.setOutputConsumer(output); identifyCmd.run(op, imagePath); ArrayList&lt;String&gt; cmdOutput = output.getOutput(); String[] result = cmdOutput.get(0).split(","); if (result.length == 6) &#123; imageInfo.put(IMAGE_WIDTH, result[0]); imageInfo.put(IMAGE_HEIGHT, result[1]); imageInfo.put(IMAGE_PATH, result[2]); imageInfo.put(IMAGE_QUALITY, result[3]); imageInfo.put(IMAGE_SIZE, result[4]); imageInfo.put(IMAGE_SUFFIX, result[5]); &#125; &#125; catch (Exception e) &#123; // e.printStackTrace(); logger.error("图片工具获取图片基本信息异常" + e.getMessage(), e); &#125; long endTime = System.currentTimeMillis(); // logger.info("take time: " + (endTime - startTime)); return imageInfo; &#125; /** * 获取 ImageCommand * * @param command 命令类型 * @return */ private static ImageCommand getImageCommand(CommandType command) &#123; ImageCommand cmd = null; switch (command) &#123; case convert: cmd = new ConvertCmd(IS_USE_GRAPHICS_MAGICK); break; case identify: cmd = new IdentifyCmd(IS_USE_GRAPHICS_MAGICK); break; case compositecmd: cmd = new CompositeCmd(IS_USE_GRAPHICS_MAGICK); break; &#125; if (cmd != null &amp;&amp; System.getProperty("os.name").toLowerCase().indexOf("windows") == -1) &#123; cmd.setSearchPath(IS_USE_GRAPHICS_MAGICK ? GRAPHICS_MAGICK_PATH : IMAGE_MAGICK_PATH); &#125; return cmd; &#125; &#125; 上面的代码中要注意几个问题： 获取 ImageCommand时，在new ConvertCmd(true)，参数要填true，不填的默认使用的是ImageMagick，参数为true时，才会使用grapicmagick的命令。 获取 ImageCommand 后，要设置命令的搜索路径，有时可能会不稳定找不到gm命令，例如 cmd.setSearchPath(“/usr/local/bin”); (gm 命令在该路径下) 获取图片信息的命令中有个参数 -format ，该参数可取的值如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445%b file size of image read in%c comment property%d directory component of path%e filename extension or suffix%f filename (including suffix)%g layer canvas page geometry ( = %Wx%H%X%Y )%h current image height in pixels%i image filename (note: becomes output filename for "info:")%k number of unique colors%l label property%m image file format (file magic)%n exact number of images in current image sequence%o output filename (used for delegates)%p index of image in current image list%q quantum depth (compile-time constant)%r image class and colorspace%s scene number (from input unless re-assigned)%t filename without directory or extension (suffix)%u unique temporary filename (used for delegates)%w current width in pixels%x x resolution (density)%y y resolution (density)%z image depth (as read in unless modified, image save depth)%A image transparency channel enabled (true/false)%C image compression type%D image dispose method%G image size ( = %wx%h )%H page (canvas) height%M Magick filename (original file exactly as given, including read mods)%O page (canvas) offset ( = %X%Y )%P page (canvas) size ( = %Wx%H )%Q image compression quality ( 0 = default )%S ?? scenes ??%T image time delay%W page (canvas) width%X page (canvas) x offset (including sign)%Y page (canvas) y offset (including sign)%Z unique filename (used for delegates)%@ bounding box%# signature%% a percent sign\n newline\r carriage return 压缩图片质量123456789101112131415161718/** * 图片压缩 * &lt;p&gt; * 拼装命令示例: gm convert -quality 80 /apps/watch.jpg /apps/watch_compress.jpg * * @param srcImagePath * @param destImagePath * @param quality * @throws Exception */ public static void compressImage(String srcImagePath, String destImagePath, double quality) throws Exception &#123; IMOperation op = new IMOperation(); op.quality(quality); op.addImage(); op.addImage(); ImageCommand cmd = getImageCommand(CommandType.convert); cmd.run(op, srcImagePath, destImagePath); &#125; 裁剪图片12345678910111213141516171819202122232425262728293031323334/** * 裁剪图片 * * @param imagePath 源图片路径 * @param newPath 处理后图片路径 * @param x 起始X坐标 * @param y 起始Y坐标 * @param width 裁剪宽度 * @param height 裁剪高度 * @return 返回true说明裁剪成功, 否则失败 */ public static boolean cutImage(String imagePath, String newPath, int x, int y, int width, int height) &#123; boolean flag = false; try &#123; IMOperation op = new IMOperation(); op.addImage(imagePath); /** width：裁剪的宽度 * height：裁剪的高度 * x：裁剪的横坐标 * y：裁剪纵坐标 */ op.crop(width, height, x, y); op.addImage(newPath); ConvertCmd convert = new ConvertCmd(true); convert.run(op); flag = true; &#125; catch (IOException e) &#123; System.out.println("文件读取错误!"); flag = false; &#125; catch (InterruptedException e) &#123; flag = false; &#125; catch (IM4JavaException e) &#123; flag = false; &#125; finally &#123; &#125; return flag; &#125; 缩放图片123456789101112131415161718192021222324252627282930313233343536/** * 根据尺寸缩放图片[等比例缩放:参数height为null,按宽度缩放比例缩放;参数width为null,按高度缩放比例缩放] * * @param imagePath 源图片路径 * @param newPath 处理后图片路径 * @param width 缩放后的图片宽度 * @param height 缩放后的图片高度 * @return 返回true说明缩放成功, 否则失败 */ public static boolean zoomImage(String imagePath, String newPath, Integer width, Integer height) &#123; boolean flag; try &#123; IMOperation op = new IMOperation(); op.addImage(imagePath); if (width == null) &#123;// 根据高度缩放图片 op.resize(null, height); &#125; else if (height == null) &#123;// 根据宽度缩放图片 op.resize(width); &#125; else &#123; op.resize(width, height); &#125; op.addImage(newPath); ConvertCmd convert = new ConvertCmd(true); convert.run(op); flag = true; &#125; catch (IOException e) &#123; System.out.println("文件读取错误!"); flag = false; &#125; catch (InterruptedException e) &#123; flag = false; &#125; catch (IM4JavaException e) &#123; flag = false; &#125; return flag; &#125; 图片旋转123456789101112131415161718192021222324252627282930/** * 图片旋转(顺时针旋转) * 拼装命令示例: gm convert -rotate 90 /apps/watch.jpg /apps/watch_compress.jpg * * @param imagePath 源图片路径 * @param newPath 处理后图片路径 * @param degree 旋转角度 */ public static boolean rotate(String imagePath, String newPath, double degree) &#123; boolean flag; try &#123; // 1.将角度转换到0-360度之间 degree = degree % 360; if (degree &lt;= 0) &#123; degree = 360 + degree; &#125; IMOperation op = new IMOperation(); op.rotate(degree); op.addImage(imagePath); op.addImage(newPath); ConvertCmd cmd = new ConvertCmd(true); cmd.run(op); flag = true; &#125; catch (Exception e) &#123; flag = false; System.out.println("图片旋转失败!"); &#125; return flag; &#125; 添加文字水印123456789101112131415161718192021222324/** * 文字水印 * * @param srcImagePath 源图片路径 * @param destImagePath 目标图片路径 * @param content 文字内容（不支持汉字） * @throws Exception */ public static void addTextWatermark(String srcImagePath, String destImagePath, String content) throws Exception &#123; IMOperation op = new IMOperation(); op.font("ArialBold"); // 文字方位-东南 op.gravity("southeast"); // 文字信息 op.pointsize(60).fill("#F2F2F2").draw("text 10,10 " + content); // 原图 op.addImage(srcImagePath); // 目标 op.addImage(destImagePath); ImageCommand cmd = getImageCommand(CommandType.convert); cmd.run(op); &#125; 添加文字前要安装文字包，或直接指向 ttf 文字格式文件上。OSX 安装 12brew install ghostscript 添加中文水印会乱码，待解决。 添加图片水印12345678910111213141516171819202122232425262728/** * 图片水印 * * @param srcImagePath 源图片路径 * @param destImagePath 目标图片路径 * @param dissolve 透明度（0-100） * @throws Exception */ public static void addImgWatermark(String srcImagePath, String destImagePath, Integer dissolve) throws Exception &#123; // 原始图片信息 BufferedImage buffimg = ImageIO.read(new File(srcImagePath)); int w = buffimg.getWidth(); int h = buffimg.getHeight(); IMOperation op = new IMOperation(); // 水印图片位置 op.geometry(watermarkImage.getWidth(null), watermarkImage.getHeight(null), w - watermarkImage.getWidth(null) - 10, h - watermarkImage.getHeight(null) - 10); // 水印透明度 op.dissolve(dissolve); // 水印 op.addImage(watermarkImagePath); // 原图 op.addImage(srcImagePath); // 目标 op.addImage(destImagePath); ImageCommand cmd = getImageCommand(CommandType.compositecmd); cmd.run(op); &#125; 参考资料im4java官网hailin0/im4java-util]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Base64简介]]></title>
      <url>%2F2016%2F09%2F10%2FBase64%2F</url>
      <content type="text"><![CDATA[Base64编码介绍Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。 比如三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。完整的base64定义可见RFC 1421和RFC 2045。编码后的数据比原始数据略长，为原来的4/3。所以当原有数据不是3字节的倍数时，会将二进制数据后补0，凑够三个字节，转换为4个Base64单元，都是补位的则用个=替代一个Base64单元。当原数据长度不是3的整数倍时，如果最后剩下一个输入数据，在编码结果后加2个“=”；如果最后剩下两个输入数据，编码结果后加1个“=”；如果没有剩下任何数据，就什么都不要加，这样才可以保证数据还原的正确性。（见下面的编码过程） Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据。包括MIME的email、在XML中存储复杂数据。使用的字符包括大小写字母各26个，加上10个数字，和加号“+”，斜杠“/”，一共64个字符，等号“=”用来作为后缀用途。 为什么使用 Base64 base64不是安全领域下的加密解密算法。能起到安全作用的效果很差，而且很容易破解，他核心作用应该是传输数据的正确性，有些网关或系统只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法，而且base64特别适合在http，mime协议下快速传输数据。 Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，Base64编码可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。 在前端应用：将图片转换为Base64编码，可以让你很方便地在没有上传文件的条件下将图片插入其它的网页、编辑器中。 这对于一些小的图片是极为方便的，因为你不需要再去寻找一个保存图片的地方。 在电子邮件传输中的应用，见下文。 base64编码过程Base64编码要求把3个8位字节（38=24）转化为4个6位的字节（46=24），之后在6位的前面补两个0，形成8位一个字节的形式。 如果剩下的字符不足3个字节，则用0填充，输出字符使用’=’，因此编码后输出的文本末尾可能会出现1或2个’=’。 具体参见文中的图：http://www.cnblogs.com/hongru/archive/2012/01/14/2321397.html文中的图清晰明了。 url base64为解决在base64后的字符在url中正常使用，可采用一种用于URL的改进Base64编码，它不在末尾填充’=’号，并将标准Base64中的“+”和“/”分别改成了“-”和“_”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。 MIME base64jdk8中提供了Base64类，实现了基本的base64，url Base64 和 mime Base64mime Base64 用在邮件传输中，在MIME格式的电子邮件中，base64可以用来将binary的字节序列数据编码成ASCII字符序列构成的文本。需要注意的是在电子邮件中，根据RFC 822规定，每76个字符，还需要加上一个回车换行。 思考base64 怎么编码中文的，utf-8中，一个汉字占3个字节 参考资料Base64 wikipediaJava 8新特性探究（十一）Base64详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java多线程——生产者和消费者模式]]></title>
      <url>%2F2016%2F08%2F15%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[生产者和消费者模式是一种并发设计模式，生产者消费者模式解决的是两者速率不一致而产生的阻抗不匹配，该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。 生产者消费者模式生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。 为什么要使用生产者和消费者模式在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。 优点 可以独立地同时编码生产者和消费者，他们只需要知道共享对象即可。 生产者不需要知道谁是消费者或有多少消费者，消费者也是如此。 生产者和消费者可以以不同的速度工作，消费者没有消费半成品的风险。 分离生产者和消费者的功能导致更干净，可读和易于管理的代码。 应用Executor框架本身也实现了生产者和消费者模式，在线程池中，如果任务数多于基本线程数时，会将任务放到阻塞队列中来平衡生产者和消费者的处理能力，关于线程池的介绍可以看我的另一篇文章 java——线程池 示例代码用阻塞队列实现先用阻塞队列来实现，BlockingQueue 是个继承Queue接口的接口，该接口有不同的实现，比如ArrayBlockingQueue 和 LinkedBlockingQueue，他们都实现了 FIFO。 用LinkedBlockingQueue实现生产者和消费者模式如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ProducerConsumerPractice &#123; public static void main(String[] args)&#123; LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque = new LinkedBlockingDeque&lt;&gt;(5); new Thread(new Producer(linkedBlockingDeque)).start(); new Thread(new Consumer(linkedBlockingDeque)).start(); &#125;&#125;class Producer implements Runnable&#123; private LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque; public Producer(LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque)&#123; this.linkedBlockingDeque = linkedBlockingDeque; &#125; public void run()&#123; for(int i = 0; i &lt; 10; i++)&#123; try &#123; //Thread.sleep(500); linkedBlockingDeque.put(i); System.out.println("Producer: " + i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Consumer implements Runnable&#123; private LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque; public Consumer(LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque)&#123; this.linkedBlockingDeque = linkedBlockingDeque; &#125; public void run()&#123; while(true)&#123; try&#123; Thread.sleep(500); System.out.println("consumer: " + linkedBlockingDeque.take()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 1234567891011121314151617181920Producer: 0Producer: 1Producer: 2Producer: 3Producer: 4consumer: 0Producer: 5consumer: 1Producer: 6consumer: 2Producer: 7consumer: 3Producer: 8consumer: 4Producer: 9consumer: 5consumer: 6consumer: 7consumer: 8consumer: 9 我设置了阻塞队列的初始长度为5，然后用sleep（500）调慢了消费速度，所以我们在运行结果中可以看到生产0-4后，队列满了，生产者被阻塞了，然后消费者根据FIFO原则先消费了0，所以生产者又可以继续生产了。在ide中运行看的会更清楚些，第二种方式实现打印的结果会更明白。 用wait(), notify() 实现之前写过一篇文章 线程间协作——wait、notify、notifyAll 讲了 wait(), notify（），notifyAll()的用法，现在用他们来实现生产者和消费者模式，当做补充例子吧。这里用 Vector 模拟队列，因为这个队列没有阻塞功能，所以要用wait()和 notify（）模拟队列满时生产者和队列为空时消费者的阻塞，以及正常情况下互相通知对方的效果。 代码中同样调慢了消费速度，为了看的更清晰。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class ProducerConsumerPractice &#123; public static void main(String[] args)&#123; Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(5); new Thread(new Producer(vector)).start(); new Thread(new Consumer(vector)).start(); &#125;&#125;class Producer implements Runnable&#123; private Vector&lt;Integer&gt; vector; public Producer(Vector vector)&#123; this.vector = vector; &#125; public void run()&#123; for(int i = 0; i &lt; 10; i++)&#123; while(vector.size() == vector.capacity())&#123; synchronized (vector)&#123; System.out.println("Queue is full, Producer is waiting , size: " + vector.size()); try &#123; vector.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; synchronized (vector)&#123; vector.add(i); System.out.println("Producer: " + i); vector.notifyAll(); &#125; &#125; &#125;&#125;class Consumer implements Runnable&#123; private Vector&lt;Integer&gt; vector; public Consumer(Vector vector)&#123; this.vector = vector; &#125; public void run()&#123; while(true)&#123; while(vector.isEmpty())&#123; synchronized (vector)&#123; System.out.println("Queue is empty, Consumer is waiting , size: " + vector.size()); try &#123; vector.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //调慢消费速度 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (vector)&#123; System.out.println("Consumer: " + vector.remove(0)); vector.notifyAll(); &#125; &#125; &#125;&#125; 运行结果： 1234567891011121314151617181920212223242526Producer: 0Producer: 1Producer: 2Producer: 3Producer: 4Queue is full, Producer is waiting , size: 5Consumer: 0Producer: 5Queue is full, Producer is waiting , size: 5Consumer: 1Producer: 6Queue is full, Producer is waiting , size: 5Consumer: 2Producer: 7Queue is full, Producer is waiting , size: 5Consumer: 3Producer: 8Queue is full, Producer is waiting , size: 5Consumer: 4Producer: 9Consumer: 5Consumer: 6Consumer: 7Consumer: 8Consumer: 9Queue is empty, Consumer is waiting , size: 0 参考资料聊聊并发——生产者消费者模式Producer Consumer Problem with Wait and Notify Example]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线程间协作——wait、notify、notifyAll]]></title>
      <url>%2F2016%2F07%2F08%2F%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8D%8F%E4%BD%9C%E2%80%94%E2%80%94wait%E3%80%81notify%E3%80%81notifyAll%2F</url>
      <content type="text"><![CDATA[在 Java 中，可以通过配合调用 Object 对象的 wait() 方法和 notify()方法或 notifyAll() 方法来实现线程间的通信。在线程中调用 wait() 方法，将阻塞等待其他线程的通知（其他线程调用 notify() 方法或 notifyAll() 方法），在线程中调用 notify() 方法或 notifyAll() 方法，将通知其他线程从 wait() 方法处返回。 wait()该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用 wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait()方法。进入 wait()方法后，当前线程释放锁。 notify()该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁。该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个 wait()状态的线程来发出通知，并使它等待获取该对象的对象锁（notify 后，当前线程不会马上释放该对象锁，wait 所在的线程并不能马上获取该对象锁，要等到程序退出 synchronized 代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们 notifyAll()该方法与 notify ()方法的工作方式相同，重要的一点差异是：notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待 notify 或 notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll 线程退出调用了 notifyAll 的 synchronized 代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。 应该在while循环，而不是if语句中调用wait。if语句存在一些微妙的小问题，导致即使条件没被满足，你的线程你也有可能被错误地唤醒。所以如果你不在线程被唤醒后再次使用while循环检查唤醒条件是否被满足，你的程序就有可能会出错。在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤醒，有可能会导致死锁问题。参考《Effective Java》 示例我之前写过一篇文章 线程执行顺序——CountDownLatch、join()、线程池 讨论的是让一个线程晚于其他线程最后执行。我想用wait和notify写个例子让一个线程先于其他线程运行。 代码场景：Worker类和Boss类都实现Runnable接口，但是老板先安排完工作后，工人才能开始工作。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class WaitAndNotify &#123; public static void main(String[] args) throws Exception&#123; Object object = new Object(); new Thread(new Worker("work1", object)).start(); new Thread(new Worker("work2", object)).start(); new Thread(new Worker("work3", object)).start(); new Thread(new Boss("boss", object)).start(); &#125;&#125;class Worker implements Runnable&#123; private String name; private Object object; public Worker(String name,Object object)&#123; this.object = object; this.name = name; &#125; public void run()&#123; synchronized(object)&#123; try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(name + " is working"); &#125; &#125;&#125;class Boss implements Runnable&#123; private String name; private Object object; public Boss(String name, Object object)&#123; this.name = name; this.object = object; &#125; public void run()&#123; synchronized(object)&#123; System.out.println(name + " has arranged the work"); object.notifyAll(); //object.notify(); &#125; &#125;&#125; 运行结果： 1234boss has arranged the workwork3 is workingwork2 is workingwork1 is working 从上面的代码中可以看到，Boss类使用notifyAll（）方法，3个worker线程都会执行，如果换成 notify（）方法，则只有一个worker线程会执行。 应用比如可以用wait和notify实现生产者和消费者，这里不细说了，有空再写下生产者和消费者吧。 总结 可以使用wait和notify函数来实现线程间通信。 在synchronized的函数或对象里使用wait、notify和notifyAll，否则Java虚拟机会生成 IllegalMonitorStateException。 在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。 在多线程间共享的对象（在生产者消费者模型里即缓冲区队列）上使用wait。 参考资料线程间协作：wait、notify、notifyAll如何在 Java 中正确使用 wait, notify 和 notifyAll – 以生产者消费者模型为例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 写blog]]></title>
      <url>%2F2016%2F05%2F12%2Fhexo%20%E5%86%99blog%2F</url>
      <content type="text"><![CDATA[hexo 写blog写文章1hexo new [layout] &lt;title&gt; 也可以不用这样，直接把markdown文章放到 source/_post 文件夹下,可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 Hexo 默认以标题做为文件名称，但可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为:year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。 添加标签 about 页面以 about 标签页为例 12345title: 标签date: 2017-2-22 12:39:04type: "about"comments: true--- 调试和部署1234hexo g //根据模板编译生成文件hexo s //本地启动服务hexo deploy //发布到github 生成文件位置：.deploy_git/ 每次部署会把 CNAME 和 README.md 删掉，可以把这两个文件放到 source 文件夹下就可以了。 常见问题# 标题 注意显示标题时，在 # 后面加个空格就可以了。 参考资料hexo中文文档 Jekyll迁移到Hexo搭建个人博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F05%2F11%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
