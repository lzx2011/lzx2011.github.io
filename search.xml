<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java多线程——生产者和消费者模式]]></title>
      <url>%2F2017%2F03%2F15%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[生产者和消费者模式是一种并发设计模式，生产者消费者模式解决的是两者速率不一致而产生的阻抗不匹配，该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。 生产者消费者模式生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。 为什么要使用生产者和消费者模式在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。 优点 可以独立地同时编码生产者和消费者，他们只需要知道共享对象即可。 生产者不需要知道谁是消费者或有多少消费者，消费者也是如此。 生产者和消费者可以以不同的速度工作，消费者没有消费半成品的风险。 分离生产者和消费者的功能导致更干净，可读和易于管理的代码。 应用Executor框架本身也实现了生产者和消费者模式，在线程池中，如果任务数多于基本线程数时，会将任务放到阻塞队列中来平衡生产者和消费者的处理能力，关于线程池的介绍可以看我的另一篇文章 java——线程池 示例代码用阻塞队列实现先用阻塞队列来实现，BlockingQueue 是个继承Queue接口的接口，该接口有不同的实现，比如ArrayBlockingQueue 和 LinkedBlockingQueue，他们都实现了 FIFO。 用LinkedBlockingQueue实现生产者和消费者模式如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ProducerConsumerPractice &#123; public static void main(String[] args)&#123; LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque = new LinkedBlockingDeque&lt;&gt;(5); new Thread(new Producer(linkedBlockingDeque)).start(); new Thread(new Consumer(linkedBlockingDeque)).start(); &#125;&#125;class Producer implements Runnable&#123; private LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque; public Producer(LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque)&#123; this.linkedBlockingDeque = linkedBlockingDeque; &#125; public void run()&#123; for(int i = 0; i &lt; 10; i++)&#123; try &#123; //Thread.sleep(500); linkedBlockingDeque.put(i); System.out.println("Producer: " + i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Consumer implements Runnable&#123; private LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque; public Consumer(LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque)&#123; this.linkedBlockingDeque = linkedBlockingDeque; &#125; public void run()&#123; while(true)&#123; try&#123; Thread.sleep(500); System.out.println("consumer: " + linkedBlockingDeque.take()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 1234567891011121314151617181920Producer: 0Producer: 1Producer: 2Producer: 3Producer: 4consumer: 0Producer: 5consumer: 1Producer: 6consumer: 2Producer: 7consumer: 3Producer: 8consumer: 4Producer: 9consumer: 5consumer: 6consumer: 7consumer: 8consumer: 9 我设置了阻塞队列的初始长度为5，然后用sleep（500）调慢了消费速度，所以我们在运行结果中可以看到生产0-4后，队列满了，生产者被阻塞了，然后消费者根据FIFO原则先消费了0，所以生产者又可以继续生产了。在ide中运行看的会更清楚些，第二种方式实现打印的结果会更明白。 用wait(), notify() 实现之前写过一篇文章 线程间协作——wait、notify、notifyAll 讲了 wait(), notify（），notifyAll()的用法，现在用他们来实现生产者和消费者模式，当做补充例子吧。这里用 Vector 模拟队列，因为这个队列没有阻塞功能，所以要用wait()和 notify（）模拟队列满时生产者和队列为空时消费者的阻塞，以及正常情况下互相通知对方的效果。 代码中同样调慢了消费速度，为了看的更清晰。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class ProducerConsumerPractice &#123; public static void main(String[] args)&#123; Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(5); new Thread(new Producer(vector)).start(); new Thread(new Consumer(vector)).start(); &#125;&#125;class Producer implements Runnable&#123; private Vector&lt;Integer&gt; vector; public Producer(Vector vector)&#123; this.vector = vector; &#125; public void run()&#123; for(int i = 0; i &lt; 10; i++)&#123; while(vector.size() == vector.capacity())&#123; synchronized (vector)&#123; System.out.println("Queue is full, Producer is waiting , size: " + vector.size()); try &#123; vector.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; synchronized (vector)&#123; vector.add(i); System.out.println("Producer: " + i); vector.notifyAll(); &#125; &#125; &#125;&#125;class Consumer implements Runnable&#123; private Vector&lt;Integer&gt; vector; public Consumer(Vector vector)&#123; this.vector = vector; &#125; public void run()&#123; while(true)&#123; while(vector.isEmpty())&#123; synchronized (vector)&#123; System.out.println("Queue is empty, Consumer is waiting , size: " + vector.size()); try &#123; vector.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //调慢消费速度 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (vector)&#123; System.out.println("Consumer: " + vector.remove(0)); vector.notifyAll(); &#125; &#125; &#125;&#125; 运行结果： 1234567891011121314151617181920212223242526Producer: 0Producer: 1Producer: 2Producer: 3Producer: 4Queue is full, Producer is waiting , size: 5Consumer: 0Producer: 5Queue is full, Producer is waiting , size: 5Consumer: 1Producer: 6Queue is full, Producer is waiting , size: 5Consumer: 2Producer: 7Queue is full, Producer is waiting , size: 5Consumer: 3Producer: 8Queue is full, Producer is waiting , size: 5Consumer: 4Producer: 9Consumer: 5Consumer: 6Consumer: 7Consumer: 8Consumer: 9Queue is empty, Consumer is waiting , size: 0 参考资料聊聊并发——生产者消费者模式Producer Consumer Problem with Wait and Notify Example]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F13%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[悲观锁和乐观锁]]></title>
      <url>%2F2017%2F03%2F11%2F%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%2F</url>
      <content type="text"><![CDATA[悲观锁和乐观锁为什么需要锁在多用户环境中，在同一时间可能会有多个用户更新相同的记录，就会产生冲突。冲突最终会导致丢失更新或脏读。 丢失更新：一个事务的更新覆盖了其它事务的更新结果。脏读：当一个事务读取其它完成一半事务的记录时，就会发生脏读取。表现为不同用户读到的同一个记录的值可能不同。 悲观锁还是乐观锁可以认为是一种思想。不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像 memcache、hibernate、tair 等都有类似的概念。不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。 当一个用户锁住数据库中的某个对象时，其他用户就不能再访问该对象。加锁对并发访问的影响体现在锁的粒度上。比如，放在一个表上的锁限制对整个表的并发访问；放在数据页上的锁限制了对整个数据页的访问；放在行上的锁只限制对该行的并发访问。可见行锁粒度最小，并发访问最好，页锁粒度最大，表锁介于两者之间。 悲观锁(Pessimistic Lock)假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。每次拿数据的时候都会担心会被别人修改（疑心重很悲观），所以每次在拿数据的时候都会上锁。确保自己使用的过程中不会被别人访问，自己使用完后再解锁，期间需要访问该数据的都会等待。 在数据库中，悲观锁的流程如下：在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 MySQL InnoDB中使用悲观锁：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0; MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。 悲观锁机制存在以下问题： 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。一个线程持有锁会导致其它所有需要此锁的线程挂起。如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。 乐观锁(Optimistic Lock)所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。[1] 乐观锁不能解决脏读的问题。每次拿数据的时候都完全不担心会被别人修改（心态好很乐观），所以每次在拿数据的时候都不会上锁。但是在更新数据的时候去判断该期间是否被别人修改过（使用版本号等机制），期间该数据可以随便被其他人读取。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本或使用时间戳。 使用方式 使用自增长的整数表示数据版本号。更新时检查版本号是否一致，比如数据库中数据版本为6，更新提交时version=6+1,使用该version值(=7)与数据库version+1(=7)作比较，如果相等，则可以更新，如果不等则有可能其他程序已更新该记录，所以返回错误。 使用时间戳来实现. 对于以上两种方式,Hibernate自带实现方式：在使用乐观锁的字段前加annotation: @Version, Hibernate在更新时自动校验该字段。 使用场景两种锁各有优缺点，不能单纯的定义哪个好于哪个。乐观锁比较适合数据修改比较少，并发量比较大，读取比较频繁的场景。但是如果经常发生冲突（写数据比较多的情况下），并发量不大且不允许脏读，上层应用不不断的retry，这样反而降低了性能，对于这种情况使用悲观锁就更合适。 java中的使用乐观锁是一种思想。CAS是这种思想的一种实现方式。乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。上面提到的乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。CAS是项乐观锁技术，CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。在JDK1.5 中新增java.util.concurrent(J.U.C)就是建立在CAS之上的。相对于对于synchronized这种阻塞算法，CAS是非阻塞算法的一种常见实现，所以J.U.C在性能上有了很大的提升。 参考：乐观锁的一种实现方式——CAS：http://www.hollischuang.com/archives/1537 Java中的线程安全问题至关重要，要想保证线程安全，就需要锁机制。锁机制包含两种：乐观锁与悲观锁。悲观锁是独占锁，阻塞锁。乐观锁是非独占锁，非阻塞锁。有一种乐观锁的实现方式就是CAS ，这种算法在JDK 1.5中引入的java.util.concurrent中有广泛应用。但是值得注意的是这种算法会存在ABA问题。 参考资料关于悲观锁和乐观锁的区别 深入理解乐观锁与悲观锁]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 写blog]]></title>
      <url>%2F2017%2F03%2F11%2Fhexo%20%E5%86%99blog%2F</url>
      <content type="text"><![CDATA[hexo 写blog写文章1hexo new [layout] &lt;title&gt; 也可以不用这样，直接把markdown文章放到 source/_post 文件夹下,可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 Hexo 默认以标题做为文件名称，但可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为:year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。 添加标签 about 页面以 about 标签页为例 12345title: 标签date: 2017-2-22 12:39:04type: "about"comments: true--- 调试和部署1234hexo g //根据模板编译生成文件hexo s //本地启动服务hexo deploy //发布到github 生成文件位置：.deploy_git/ 每次部署会把 CNAME 和 README.md 删掉，可以把这两个文件放到 source 文件夹下就可以了。 常见问题# 标题 注意显示标题时，在 # 后面加个空格就可以了。 参考资料hexo中文文档 Jekyll迁移到Hexo搭建个人博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线程间协作——wait、notify、notifyAll]]></title>
      <url>%2F2017%2F02%2F11%2F%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8D%8F%E4%BD%9C%E2%80%94%E2%80%94wait%E3%80%81notify%E3%80%81notifyAll%2F</url>
      <content type="text"><![CDATA[在 Java 中，可以通过配合调用 Object 对象的 wait() 方法和 notify()方法或 notifyAll() 方法来实现线程间的通信。在线程中调用 wait() 方法，将阻塞等待其他线程的通知（其他线程调用 notify() 方法或 notifyAll() 方法），在线程中调用 notify() 方法或 notifyAll() 方法，将通知其他线程从 wait() 方法处返回。 wait()该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用 wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait()方法。进入 wait()方法后，当前线程释放锁。 notify()该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁。该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个 wait()状态的线程来发出通知，并使它等待获取该对象的对象锁（notify 后，当前线程不会马上释放该对象锁，wait 所在的线程并不能马上获取该对象锁，要等到程序退出 synchronized 代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们 notifyAll()该方法与 notify ()方法的工作方式相同，重要的一点差异是：notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待 notify 或 notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll 线程退出调用了 notifyAll 的 synchronized 代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。 应该在while循环，而不是if语句中调用wait。if语句存在一些微妙的小问题，导致即使条件没被满足，你的线程你也有可能被错误地唤醒。所以如果你不在线程被唤醒后再次使用while循环检查唤醒条件是否被满足，你的程序就有可能会出错。在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤醒，有可能会导致死锁问题。参考《Effective Java》 示例我之前写过一篇文章 线程执行顺序——CountDownLatch、join()、线程池 讨论的是让一个线程晚于其他线程最后执行。我想用wait和notify写个例子让一个线程先于其他线程运行。 代码场景：Worker类和Boss类都实现Runnable接口，但是老板先安排完工作后，工人才能开始工作。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class WaitAndNotify &#123; public static void main(String[] args) throws Exception&#123; Object object = new Object(); new Thread(new Worker("work1", object)).start(); new Thread(new Worker("work2", object)).start(); new Thread(new Worker("work3", object)).start(); new Thread(new Boss("boss", object)).start(); &#125;&#125;class Worker implements Runnable&#123; private String name; private Object object; public Worker(String name,Object object)&#123; this.object = object; this.name = name; &#125; public void run()&#123; synchronized(object)&#123; try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(name + " is working"); &#125; &#125;&#125;class Boss implements Runnable&#123; private String name; private Object object; public Boss(String name, Object object)&#123; this.name = name; this.object = object; &#125; public void run()&#123; synchronized(object)&#123; System.out.println(name + " has arranged the work"); object.notifyAll(); //object.notify(); &#125; &#125;&#125; 运行结果： 1234boss has arranged the workwork3 is workingwork2 is workingwork1 is working 从上面的代码中可以看到，Boss类使用notifyAll（）方法，3个worker线程都会执行，如果换成 notify（）方法，则只有一个worker线程会执行。 应用比如可以用wait和notify实现生产者和消费者，这里不细说了，有空再写下生产者和消费者吧。 总结 可以使用wait和notify函数来实现线程间通信。 在synchronized的函数或对象里使用wait、notify和notifyAll，否则Java虚拟机会生成 IllegalMonitorStateException。 在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。 在多线程间共享的对象（在生产者消费者模型里即缓冲区队列）上使用wait。 参考资料线程间协作：wait、notify、notifyAll如何在 Java 中正确使用 wait, notify 和 notifyAll – 以生产者消费者模型为例]]></content>
    </entry>

    
  
  
</search>
