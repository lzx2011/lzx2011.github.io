<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java多线程——生产者和消费者模式]]></title>
      <url>%2F2017%2F03%2F15%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[生产者和消费者模式是一种并发设计模式，生产者消费者模式解决的是两者速率不一致而产生的阻抗不匹配，该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。 生产者消费者模式生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。 为什么要使用生产者和消费者模式在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。 优点 可以独立地同时编码生产者和消费者，他们只需要知道共享对象即可。 生产者不需要知道谁是消费者或有多少消费者，消费者也是如此。 生产者和消费者可以以不同的速度工作，消费者没有消费半成品的风险。 分离生产者和消费者的功能导致更干净，可读和易于管理的代码。 应用Executor框架本身也实现了生产者和消费者模式，在线程池中，如果任务数多于基本线程数时，会将任务放到阻塞队列中来平衡生产者和消费者的处理能力，关于线程池的介绍可以看我的另一篇文章 java——线程池 示例代码用阻塞队列实现先用阻塞队列来实现，BlockingQueue 是个继承Queue接口的接口，该接口有不同的实现，比如ArrayBlockingQueue 和 LinkedBlockingQueue，他们都实现了 FIFO。 用LinkedBlockingQueue实现生产者和消费者模式如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ProducerConsumerPractice &#123; public static void main(String[] args)&#123; LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque = new LinkedBlockingDeque&lt;&gt;(5); new Thread(new Producer(linkedBlockingDeque)).start(); new Thread(new Consumer(linkedBlockingDeque)).start(); &#125;&#125;class Producer implements Runnable&#123; private LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque; public Producer(LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque)&#123; this.linkedBlockingDeque = linkedBlockingDeque; &#125; public void run()&#123; for(int i = 0; i &lt; 10; i++)&#123; try &#123; //Thread.sleep(500); linkedBlockingDeque.put(i); System.out.println("Producer: " + i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Consumer implements Runnable&#123; private LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque; public Consumer(LinkedBlockingDeque&lt;Integer&gt; linkedBlockingDeque)&#123; this.linkedBlockingDeque = linkedBlockingDeque; &#125; public void run()&#123; while(true)&#123; try&#123; Thread.sleep(500); System.out.println("consumer: " + linkedBlockingDeque.take()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 1234567891011121314151617181920Producer: 0Producer: 1Producer: 2Producer: 3Producer: 4consumer: 0Producer: 5consumer: 1Producer: 6consumer: 2Producer: 7consumer: 3Producer: 8consumer: 4Producer: 9consumer: 5consumer: 6consumer: 7consumer: 8consumer: 9 我设置了阻塞队列的初始长度为5，然后用sleep（500）调慢了消费速度，所以我们在运行结果中可以看到生产0-4后，队列满了，生产者被阻塞了，然后消费者根据FIFO原则先消费了0，所以生产者又可以继续生产了。在ide中运行看的会更清楚些，第二种方式实现打印的结果会更明白。 用wait(), notify() 实现之前写过一篇文章 线程间协作——wait、notify、notifyAll 讲了 wait(), notify（），notifyAll()的用法，现在用他们来实现生产者和消费者模式，当做补充例子吧。这里用 Vector 模拟队列，因为这个队列没有阻塞功能，所以要用wait()和 notify（）模拟队列满时生产者和队列为空时消费者的阻塞，以及正常情况下互相通知对方的效果。 代码中同样调慢了消费速度，为了看的更清晰。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class ProducerConsumerPractice &#123; public static void main(String[] args)&#123; Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(5); new Thread(new Producer(vector)).start(); new Thread(new Consumer(vector)).start(); &#125;&#125;class Producer implements Runnable&#123; private Vector&lt;Integer&gt; vector; public Producer(Vector vector)&#123; this.vector = vector; &#125; public void run()&#123; for(int i = 0; i &lt; 10; i++)&#123; while(vector.size() == vector.capacity())&#123; synchronized (vector)&#123; System.out.println("Queue is full, Producer is waiting , size: " + vector.size()); try &#123; vector.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; synchronized (vector)&#123; vector.add(i); System.out.println("Producer: " + i); vector.notifyAll(); &#125; &#125; &#125;&#125;class Consumer implements Runnable&#123; private Vector&lt;Integer&gt; vector; public Consumer(Vector vector)&#123; this.vector = vector; &#125; public void run()&#123; while(true)&#123; while(vector.isEmpty())&#123; synchronized (vector)&#123; System.out.println("Queue is empty, Consumer is waiting , size: " + vector.size()); try &#123; vector.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //调慢消费速度 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (vector)&#123; System.out.println("Consumer: " + vector.remove(0)); vector.notifyAll(); &#125; &#125; &#125;&#125; 运行结果： 1234567891011121314151617181920212223242526Producer: 0Producer: 1Producer: 2Producer: 3Producer: 4Queue is full, Producer is waiting , size: 5Consumer: 0Producer: 5Queue is full, Producer is waiting , size: 5Consumer: 1Producer: 6Queue is full, Producer is waiting , size: 5Consumer: 2Producer: 7Queue is full, Producer is waiting , size: 5Consumer: 3Producer: 8Queue is full, Producer is waiting , size: 5Consumer: 4Producer: 9Consumer: 5Consumer: 6Consumer: 7Consumer: 8Consumer: 9Queue is empty, Consumer is waiting , size: 0 参考资料聊聊并发——生产者消费者模式Producer Consumer Problem with Wait and Notify Example]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F13%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线程间协作——wait、notify、notifyAll]]></title>
      <url>%2F2017%2F02%2F11%2F%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8D%8F%E4%BD%9C%E2%80%94%E2%80%94wait%E3%80%81notify%E3%80%81notifyAll%2F</url>
      <content type="text"><![CDATA[在 Java 中，可以通过配合调用 Object 对象的 wait() 方法和 notify()方法或 notifyAll() 方法来实现线程间的通信。在线程中调用 wait() 方法，将阻塞等待其他线程的通知（其他线程调用 notify() 方法或 notifyAll() 方法），在线程中调用 notify() 方法或 notifyAll() 方法，将通知其他线程从 wait() 方法处返回。 wait()该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用 wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait()方法。进入 wait()方法后，当前线程释放锁。 notify()该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁。该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个 wait()状态的线程来发出通知，并使它等待获取该对象的对象锁（notify 后，当前线程不会马上释放该对象锁，wait 所在的线程并不能马上获取该对象锁，要等到程序退出 synchronized 代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们 notifyAll()该方法与 notify ()方法的工作方式相同，重要的一点差异是：notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒，不再等待 notify 或 notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll 线程退出调用了 notifyAll 的 synchronized 代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。 应该在while循环，而不是if语句中调用wait。if语句存在一些微妙的小问题，导致即使条件没被满足，你的线程你也有可能被错误地唤醒。所以如果你不在线程被唤醒后再次使用while循环检查唤醒条件是否被满足，你的程序就有可能会出错。在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤醒，有可能会导致死锁问题。参考《Effective Java》 示例我之前写过一篇文章 线程执行顺序——CountDownLatch、join()、线程池 讨论的是让一个线程晚于其他线程最后执行。我想用wait和notify写个例子让一个线程先于其他线程运行。 代码场景：Worker类和Boss类都实现Runnable接口，但是老板先安排完工作后，工人才能开始工作。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class WaitAndNotify &#123; public static void main(String[] args) throws Exception&#123; Object object = new Object(); new Thread(new Worker("work1", object)).start(); new Thread(new Worker("work2", object)).start(); new Thread(new Worker("work3", object)).start(); new Thread(new Boss("boss", object)).start(); &#125;&#125;class Worker implements Runnable&#123; private String name; private Object object; public Worker(String name,Object object)&#123; this.object = object; this.name = name; &#125; public void run()&#123; synchronized(object)&#123; try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(name + " is working"); &#125; &#125;&#125;class Boss implements Runnable&#123; private String name; private Object object; public Boss(String name, Object object)&#123; this.name = name; this.object = object; &#125; public void run()&#123; synchronized(object)&#123; System.out.println(name + " has arranged the work"); object.notifyAll(); //object.notify(); &#125; &#125;&#125; 运行结果： 1234boss has arranged the workwork3 is workingwork2 is workingwork1 is working 从上面的代码中可以看到，Boss类使用notifyAll（）方法，3个worker线程都会执行，如果换成 notify（）方法，则只有一个worker线程会执行。 应用比如可以用wait和notify实现生产者和消费者，这里不细说了，有空再写下生产者和消费者吧。 总结 可以使用wait和notify函数来实现线程间通信。 在synchronized的函数或对象里使用wait、notify和notifyAll，否则Java虚拟机会生成 IllegalMonitorStateException。 在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。 在多线程间共享的对象（在生产者消费者模型里即缓冲区队列）上使用wait。 参考资料线程间协作：wait、notify、notifyAll如何在 Java 中正确使用 wait, notify 和 notifyAll – 以生产者消费者模型为例]]></content>
    </entry>

    
  
  
</search>
